import os
import requests
from typing import List, Dict, Any
from src.ports.interfaces import SubtitleGeneratorPort
from src.domain.entities import Segment, Word, TimeRange

class AssSubtitleGenerator(SubtitleGeneratorPort):
    def __init__(self, font_url: str = "https://subtitle-generator.annasblackhat.web.id/fonts/the_bold.ttf"):
        self.font_url = font_url
        self.font_filename = "TheBoldFont.ttf"
        self.subtitle_style = {
            'FontName': 'THE BOLD FONT FREE VERSION',
            'FontSize': 18,
            'PrimaryColour': '&H00FFFFFF',
            'OutlineColour': '&H00000000',
            'BackColour': '&H80000000',
            'BorderStyle': 1,
            'Shadow': 0,
            'Alignment': 2,
            'MarginV': 60,
            'ActiveFontSize': 24,
            'ActivePrimaryColour': '&H0000FF00', # Green
        }
        self._ensure_font_installed()

    def _ensure_font_installed(self):
        font_dir = "/usr/local/share/fonts"
        font_path = os.path.join(font_dir, self.font_filename)
        
        # Try local fallback if not root
        local_font_dir = os.path.expanduser("~/.local/share/fonts")
        local_font_path = os.path.join(local_font_dir, self.font_filename)
        
        target_path = font_path if os.access(os.path.dirname(font_dir) if not os.path.exists(font_dir) else font_dir, os.W_OK) else local_font_path
        os.makedirs(os.path.dirname(target_path), exist_ok=True)
        
        if not os.path.exists(target_path):
            print(f"[SubtitleGenerator] Downloading font from {self.font_url}...")
            try:
                response = requests.get(self.font_url, timeout=10)
                response.raise_for_status()
                with open(target_path, 'wb') as f:
                    f.write(response.content)
                print(f"[SubtitleGenerator] Font installed to {target_path}")
                
                # Try to refresh font cache
                import subprocess
                try:
                    subprocess.run(["fc-cache", "-fv"], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                except Exception:
                    print("[SubtitleGenerator] Warning: Could not run fc-cache.")
            except Exception as e:
                print(f"[SubtitleGenerator] Failed to download font: {e}")

    def _format_ass_time(self, seconds: float) -> str:
        total_centis = int(round(seconds * 100))
        hours = total_centis // 360000
        minutes = (total_centis % 360000) // 6000
        secs = (total_centis % 6000) // 100
        centis = total_centis % 100
        return f"{hours}:{minutes:02d}:{secs:02d}.{centis:02d}"

    def get_words_for_clip(self, all_segments: List[Segment], clip_ranges: List[TimeRange]) -> List[Dict[str, Any]]:
        all_words = []
        for segment in all_segments:
            if segment.words:
                all_words.extend(segment.words)

        clip_words = []
        current_clip_time = 0.0
        
        for seg in clip_ranges:
            seg_start = seg.start
            seg_end = seg.end
            seg_duration = seg_end - seg_start
            
            words_in_seg = [w for w in all_words if w.start >= seg_start and w.end <= seg_end]
            
            for w in words_in_seg:
                shifted_word = {
                    'word': w.text.strip(),
                    'start': w.start - seg_start + current_clip_time,
                    'end': w.end - seg_start + current_clip_time
                }
                clip_words.append(shifted_word)
            
            current_clip_time += seg_duration
            
        return clip_words

    def generate(self, segments: List[Segment], clip_ranges: List[TimeRange], output_path: str) -> str:
        words = self.get_words_for_clip(segments, clip_ranges)
        if not words:
            print("[SubtitleGenerator] No words found for this clip.")
            return ""

        header = f"""[Script Info]
Title: Generated by AI Subtitle Generator
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{self.subtitle_style['FontName']},{self.subtitle_style['FontSize']},{self.subtitle_style['PrimaryColour']},&H000000FF,{self.subtitle_style.get('OutlineColour', '&H00000000')},{self.subtitle_style.get('BackColour', '&H00000000')},0,0,0,0,100,100,0,0,{self.subtitle_style['BorderStyle']},2,{self.subtitle_style.get('Shadow', 0)},{self.subtitle_style['Alignment']},10,10,{self.subtitle_style['MarginV']},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
        dialogue_lines = []
        current_line_words = []
        style = self.subtitle_style
        
        def process_line(line_words):
            if not line_words: return
            
            line_start = line_words[0]['start']
            line_end = line_words[-1]['end']
            
            if 'ActiveFontSize' in style and 'ActivePrimaryColour' in style:
                for idx, active_word in enumerate(line_words):
                    next_word = line_words[idx + 1] if idx + 1 < len(line_words) else None
                    event_end = next_word['start'] if (next_word and next_word['start'] > active_word['end']) else active_word['end']
                    
                    text_parts = []
                    for w in line_words:
                        if w == active_word:
                            text_parts.append(f"{{\\1c{style['ActivePrimaryColour']}\\fs{style['ActiveFontSize']}}}{w['word']}{{\\1c{style['PrimaryColour']}\\fs{style['FontSize']}}}")
                        else:
                            text_parts.append(w['word'])
                    
                    dialogue_text = ' '.join(text_parts)
                    dialogue = f"Dialogue: 0,{self._format_ass_time(active_word['start'])},{self._format_ass_time(event_end)},Default,,0,0,0,,{dialogue_text}"
                    dialogue_lines.append(dialogue)
            else:
                full_text = ' '.join([w['word'] for w in line_words])
                dialogue = f"Dialogue: 0,{self._format_ass_time(line_start)},{self._format_ass_time(line_end)},Default,,0,0,0,,{full_text}"
                dialogue_lines.append(dialogue)

        pause_threshold = 0.2
        for i, word in enumerate(words):
            current_line_words.append(word)
            
            next_word = words[i+1] if i+1 < len(words) else None
            is_last_word = i == len(words) - 1
            word_count = len(current_line_words)
            is_long_pause = next_word and (next_word['start'] - word['end'] > pause_threshold)
            
            if is_last_word or is_long_pause or word_count >= 3:
                process_line(current_line_words)
                current_line_words = []
                
        ass_content = header + '\n'.join(dialogue_lines)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(ass_content)
            
        return output_path
